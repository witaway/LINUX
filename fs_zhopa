![[Lab10.2_linux.pdf]]


---

# Упражнение 0. Предварительные указания

## 1. Проверим, установлены ли все пакеты

В дистрибутиве Arch (пакетный менеджер Pacman) проверить факт установленности тех или иных пакетов можно с помощью команды `pacman -Q packet-name1 packet-name2 ...`:

![[fs_check_installed.png]]

Установим недостающие при помощи команды `pacman -S`:

![[fs_install_missing.png]]

Теперь у нас всё, что нужно, установлено. Проверим:

![[fs_all_installed.png]]

## 2. Получим информацию о разделах

Воспользуемся утилитой `fsblk -o param1,param2,...`, которая получает информацию о блочных устройствах. Также мы могли бы воспользоваться утилитой `fdisk -l`, однако для текущей задачи `fsblk` мне симпатизирует больше из-за простоты изменения выходного формата:

![[fs_info_1_lsblk.png]]

Также мы хотим получить информацию о размере блока в файловой системе. Для этого можем воспользоваться утилитой `tune2fs`, которая получает информацию о файловой системе и отфильтровать её вывод при помощи утилиты `grep`:

![[fs_info_2_tune2fs.png]]

## 3. Что по меткам дисков?

Узнать или поменять метку диска, можем воспользоваться утилитой `e2label`. Сделаем сразу два действия и сначала узнаем имя диска, а затем переименуем его:

![[fs_e2label 1.png]]

Ой. А что, если системе использовала метку диска для монтирования? Это было бы неловко. Проверим, что там в `/etc/fstab`:

![[fs_check_is_label_used.png]]

Пронесло! Разработчики инсталлера предусмотрели нашу тягу к кастомизации и настроили монтирование всех ФС по идентификатору.

А решить обратную задачу и найти по метке диск мы можем при помощи утилиты `findfs`. Вообще, с помощью неё мы можем по разным параметрам искать диски.

![[fs_find_by_label.png]]


# Упражнение 1. Создание и монтирование файловой системы

## 1. Создадим файл диска

Взять раздел на диске каждый сможет - а мы хотим в файле. Там у нас будут храниться секретные данные. Аж монтировать страшно.

При помощи `dd` заполним некий файл `mydisk` нулями. Пусть его размер в байтах будет 256Мб. Далее при помощи утилиты `du` узнаем, каков его размер. Должно совпадать.

![[fs_task1_1_createdisk.png]]

## 2. Создадим на этом файле файловую систему

Создадим файловую систему `ext4` на всём файле.

![[fs_task1_2_formatdisk.png]]

## 3. Отключим проверки на этой ФС

Для этого воспользуемся утилитой `tune2fs` с соответствующими параметрами.

![[fs_task1_3_disable_fscheck.png]]

## 4. И пусть ещё у этой ФС будет метка!

![[fs_task1_4_setlabel.png]]

`e2label` работает отлично! Даже если файловая система находится на файле на диске.

## 5. Примонтируем файловую систему

Воспользуемся утилитой `mount` и не забудем про аргумент `-o loop`, который указывает, что мы монтируем именно `loop device`/`lofi (loop file interface)`. `loop device` - псевдо-устройство, которое делает компьютерный файл доступен как блочное устройство. 

![[fs_task1_5_mount.png]]

Проверим, как отработали наши команды.

![[fs_task1_6_mount_complete.png]]

## 6. Не хочу монтировать каждый раз вручную. Хочу записать в `/etc/fstab`!

Пожалуйста! Формат `/etc/fstab` прост как палка и в дополнительных объяснениях не нуждается.

![[fs_task1_7_save_to_fstab.png]]

Перезагрузимся и проверим, как оно работает.

![[fs_task1_8_fstab_works.png]]

Всё работает просто супер! Скриншот такой же, как и позапредыдущий, но я честно-честно создавал другой и честно-честно перезагружался.



# Упражнение 2. Создание и монтирование раздела подкачки

## 1. Создадим раздел на жёстком диске

Нам нужен swap - нам нужен раздел. Создадим его при помощи утилиты `fdisk`.

1. Создадим новый раздел при помощи команды `n`. Далее введём запрашиваемые утилитой параметры.
2. Проверим, всё ли вообще в порядке с таблицей разделов при помощи команды `p`.
3. Запишем изменения на диск при помощи команды `w`
4. Удивимся убогости идеи однобуквенных команд и тому, что в неинтерактивном режиме вывод таблицы разделов осуществлялся при помощи аргумента `-l`, а в интерактивном уже командой `p`.

![[fs_task2_1_make_swap_partition.png]]

## 2. Отформатируем раздел как swap

Воспользуемся командой `mkswap`

![[fs_task2_2_mkswap.png]]

## 3. Включим использование этого раздела как подкачки

Для этого подойдёт утилита `swapon`. Для обратного действия мы бы пользовались `swapoff`.

![[fs_task2_3_swapon.png]]

## 4. Проверим, как там он себе поживает

Нужная информация хранится в виртуальном файле `/proc/swaps`

![[fs_task2_4_check.png]]

## 5. Я перезгрузился и всё пропало

`swapon` монтирует файл/раздел как подкачку лишь временно, до перезагрузки. Если бы мы хотели получить перманентные изменения, то снова обратились бы к файлу `/etc/fstab`

За той лишь разницой, что:
1. вместо точки монтирования мы указываем `none`
2. тип файловой системы `swap`
3. в параметрах указываем `sw` - что означает, что при выполнение `swapon -a` эта ФС будет использоваться в качестве `swap`. swap-разделы без указания этого параметра хоть и примонтируются при загрузке, однако использованы не будут.
4. Отключаем бекапинг этой ФС (предпоследнее поле `dump`)
5. Отключаем проверку этой ФС (последнее поле `pass`)

```bash
UUID=xxx    none    swap    sw      0   0
```




# Упражнение 3. Проверка раздела на наличие ошибок

## 1. Проверка `badblocks`

К сожалению, проверка ФС на наличие ошибок возможна только если она не примонтирована. Поэтому перезагружаемся в live-образ.

Проверим раздел на наличие битых блоков при помощи утилиты `badblocks`.

При вызове `badblocks -vsw /dev/sda3` получаем следующее:

1. `v` - verbose mode. В процессе работы выводит информацию о количестве найденных ошибок на данный момент (чтения, записи, найденные повреждений данных.)
2. `s` - выводит прогресс сканирования в процентах
3. `w` - указывает проводить сканирование записью некоторых паттернов на каждом блоке устройства, далее чтением каждого блока и сравнением ожидаемого и действительного.
4. А вот если бы мы хотели проводить проверку точно ничего не ломая, вызвали бы с аргументом `n` - non-destructive mode. В нём запись на диск не осуществляется.

![[fs_task3_1_badblocks 1.png]]

Ошибки не найдены, чудно.

Но я всё равно очень сильно недоволен. Пока писал про не-деструктивный режим, деструктивный режим патчил мою файловую систему. Зато на диске точно нет ошибок.

![[fs_task3_2_broken.png]]

Ничего не грузится!

Достаём нож из спины; переустанавливаем систему; продолжаем выполнение лабораторной работы.

## 2. Проверка `fsck`

`fsck` проверяет указанный диск на наличие логических ошибок и далее автоматически пытается их исправить. Работает для файловых систем, относящихся к семейству ext.

Процесс практически полностью автоматический. Утилита по выполнению возвращает следующие коды:

> 0 – No errors
> 1 – Filesystem errors corrected
> 2 – System should be rebooted
> 4 – Filesystem errors left uncorrected
> 8 – Operational error
> 16 – Usage or syntax error
> 32 – Fsck canceled by user request
> 128 – Shared-library error

![[fs_task3_4_fsck.png]]

У нас всё хорошо. Переходим к следующему заданию.



# Упражнение 4. Всякое про LVM

## 1. Создание физического раздела под LVM

Во всех инструкциях в интернете физический раздел под LVM создавали на новом диске. А где-то и вовсе диск целиком форматировали как один большой физический раздел LVM без кончиков. Я решил провести дерзкий эксперимент и создать таковой раздел рядом с моими остальными. Удовольствию не было предела, когда это заработало. В общем и целом, не удивительно. Но вообще - приятно.

Создадим раздел на диске по инструкции аналогичной предыдущей, но тип раздела установим как LVM при помощи команды `t`.

![[fs_task4_makepart.png]]

## 2. Назначаем физический раздел как новый физический том LVM

Для этого воспользуемся утилитой `pvcreate`.

![[fs_task4_makelvm 1.png]]

## 3. Создаём на физическом томе LVM логический раздел 

Для этого воспользуемся утилитой `lvcreate`. Не забудем помимо имени логического раздела указать имя группы. Также читаем условие лабораторной работы наперёд, спохватываемся и не забываем обязательно оставить пустое пространство на физическом томе как задел для будущих экспериментов. Физический том - 1 гигабайт, логический раздел - 250 мегабайт.

![[fs_task4_makelogical 1.png]]

## 4. Форматируем логический раздел в ext4

![[fs_task4_createfs.png]]

## 5. Монтируем логический раздел

Полагаю, магия `fstab` здесь тоже должна работать. Иначе ж никак.

![[fs_task4_mount.png]]

## 6. Создаём большой-большой файл

Нам невероятно хочется, до дрожи в руках, проводить эксперименты над LVM-томом. Не осуждаемо, даже одобряемо.

Воспользуемся утилитой `dd` и создадим какой-нибудь случайный файл размером 210 мегабайт. Не забудем проверить его контрольную сумму при помощи `md5sum`.

![[fs_task4_bigfile.png]]

## 7. Кстати, а чо там по таблице разделов?

Хочу написать команду и увидеть логические разделы LVM!

К сожалению, `fdisk` утилита всё-таки немного тугенькая и логические разделы видеть не может. Для неё это всё один большой физический. Как бы и права, но нас это не устраивает. Картинок не будет, я забыл сделать. Предлагаю верить на слово.

Быстро находим ей замену: `lvs`, `lvdisplay` и `lsblk`

`lvs` мы уже пробовали, да и не такая она информативная. Не прикольно, но знать нужно.

`lvdisplay` уже интереснее! Навыводила нам всякой информации, что очень приятно:

![[fs_task4_lsparts_1.png]]

`lsblk` - мой маленький приятный сюрприз на сегодня.

Теперь буду использовать её для вывода списка разделов. Она мало того, что лучше, чем `fdisk` кастомизируется, так она ещё и логические разделы умеет выводить. Да не абы как, а древовидно, рядом со всеми остальными обычными разделами. Смотришь на это всё и в голове сразу появляется цельная картина происходящего на диске. Супер-НЯ.

![[fs_task4_lsparts_2.png]]

## 8. Хочу сделать раздел больше!

Не проблема. Сначала меняем размер логического раздела (утилита `lvresize`), затем меняем размер непосредственно файловой системы (утилита `resizefs`). 

Это имеет смысл, поскольку мы не можем увеличить файловую систему в пустоту. Сначала нужно, чтобы появилось какое-то пространство.

Перед `resize2fs` требуется обязательно запустить `e2fsck` (она даже напомнит об этом), поскольку для изменения файловой системы нужно обязательно убедиться в её целостности. Иначе возможны поломки. 

Мой вопрос только в том, почему это обязательно, а не на страх и риск, а также в том, откуда `resize2fs` знает, что я не запускал `e2fsck`? Возможно, тезис, приведённый выше, был ложен. В общем и целом, я, на саом деле, не знаю, почему оно так. И вообще, мне это рассказал ChatGPT. Не несу никакой ответственности.

P.s. Он был прав.

В любом случае, мы захотели - мы поменяли

![[fs_task4_make_bigger.png]]

У теперь примонтируем файловую систему и убедимся, что пространства стало больше, а файл даже не повредился:

![[fs_task4_make_bigger_check.png]]

## 9. Хочу сделать раздел меньше!

Прям очень хочется? Сначала нужно уменьшить размер файловой системы и лишь затем уменьшить размер логического раздела. 

Это логично, поскольку при выполнении команд в обратном порядке мы просто повредим файловую систему, обрезав её (она не ожидала!)

В остальном, алогоритм применения всех используемых утилит остаётся таким же.

![[fs_task4_make_smaller.png]]

Произошло что-то странное. Изначально размер ФС был 250 мегабайт. После увеличения до 500 мегабайт я попытался уменьшить её обратно до 250 мегабайт, но не смог. Оно утверждает, что хочет не меньше 340 мегабайт. К хорошей жизни быстро привыкаешь? 

В любом случае, монтируем файловую систему и проверяем, что ничего не поломалось и пространства снова стало мало:

![[fs_task4_make_smaller_check.png]]

## 10. Всё это мне жутко надоело, удаляю

Воспользуемся утилитой `vgremove` и снесём сразу всю группу. Для удаления отдельного логического раздела могли бы воспользоваться `lvremove`.

![[fs_task4_delete_all.png]]

Потом я удалил оставшийся раздел при помощи утилиты `fdisk`, но это осталось за кадром. Использовал команду `d`.

# Упражнение 5. Создаём RAID
## 0. Лирическое отступление

Каждый мальчик рано или поздно превращается в мужчину. У кого-то вырастает борода, у кого-то появляется плешь на голове. Это происходит когда мальчик впервые создаёт RAID-массив. Страшно осознавать, что пришёл мой черёд.

## 1. Создадим виртуальные жёсткие диски и подключим их к виртуальной машине

Сначала создадим виртуальные диски:

![[Pasted image 20231029024654.png]]

А затем подключим их:

![[Pasted image 20231029024731.png]]

Проверяем, как поживают:

![[fs_task5_pre.png]]

## 2. Создаём разделы на дисках

Мне это даёт только одно: RAID-массив может состоять не только из дисков, но и, например, из нескольких дисков и раздела на ещё одном.

**Сообщение из будего от меня же.** В книге таки осветили этот момент. Дело в том, что если компонентами массива RAID являются необработанные диски, заменить их можно только идентичными дисками. Компоненты, имеющие разделы, можно заменить любым разделом такого же размера, хотя, с точки зрения соответствия полос пропускания, лучше, если аппаратное обеспечение диском всё же является одинаковым.

Создаём на каждом диске большой-большой раздел размером с весь диск типа "unformatted". А ещё лучше "raid". Возьму второе. `fdisk` как раз предлагает.

![[fs_task5_1_mkpart.png]]

За кадром повторяю аналогичную процеду для `/dev/sdc` и `/dev/sdd`

## 3. Создём RAID-массив

Поскольку утилита `mdadm` вообще за всё отвечает, что про RAID (Вот бы так и с другими утилитами! Надоело запоминать бесконечные имена. У неё ещё есть и нормальные полные имена параметров. Хотя в книге об этом ни слова!), обращаемся к ней:

![[fs_task5_2_create_raid.png]]

Ну всё, теперь они трое - одно общее коллективное целое.

## 4. Хочу, чтобы само грузилось и меня не трогало

Как здесь принято, для этого надо написать конфиг. Как подсказывает умная книга, просто выполнить `mdadm --detail --scan` недостаточно, полученный конфиг будет неполным. Поэтому в ручном режиме добавляем информацию о дисках, которые входят в состав RAID-массива.

![[fs_task5_3_create_conf.png]]

Теперь будет всё волшебно. Загрузился - и RAID-массив тоже загрузился.

## 5. Хочу вручную включить и вручную отключить

> Вручную включить то, что уже включилось автоматически уже не получится, поэтому в целях наглядности перед выполнением этого пункта я отключил RAID-массив при помощи команды `mdadm -S /dev/md0`. Однако стоит держать у себя в голове, что при загрузке он всё отлично сам подключает исходя из написанного на прошлом шаге конфига.

Для ручного включения используется команда `mdadm -As /dev/mdX`. Для ручного отключения используется команда `mdadm -S /dev/mdX`. При этом информация о разделах берётся автоматически из файла `/etc/mdadm.conf`.

Продемонстрируем работу этих двух команд:

![[fs_task5_4_enable.png]]

![[fs_task5_5_disable.png]]

## 6. Представим, что что-то поломалось

> Для начала, чтобы узнать, что что-то поломалось, нам нужен некого рода мониторинг. За это отвечает служба `mdmonitor`. Однако для её работы нужно в `/etc/mdadm.conf` установить параметр `MAILADDR user@domain`. Я не хочу раздувать лабораторную работу, так что обойдёмся. Вся суть в том, что нам будут приходить на почту всякие интересные сообщения о происходящем с RAID-массивом. В том числе ошибки.

Помимо отправки информации по электронной почте, у нас есть логи.

Ранее применялся файл `/var/log/messages`. Теперь те же самые логи можно прочитать используя `journalctl -xe`.

Для эмуляции ошибки диска в `mdadm` существует соответствующий параметр:

![[fs_task5_6_faulty.png]]

Посмотрим, что теперь в логах:

![[fs_task5_7_faulty_logs 1.png]]

Такой диск мы можем удалить из RAID-массива и, например, как-то починить. Может заменить. Применяется команда `mdadm /dev/mdX --remove /dev/sdXC`:

![[fs_task5_8_remove.png]]

Вот мы диск наш починили, восстановили, заменили. Теперь добавим его обратно в массив:

![[fs_task5_9_add.png]]

А он даже не просто добавляется. Происходят некие процессы восстанавления. Полагаю, из-за того, что технология RAID предназначена для избыточного надёжного хранения данных, они там сейчас как раз и копировались на новоподключенный диск.

## 7. RAID-массив это круто, но там же нет файловой системы. ГДЕ ХРАНИТЬ ДАННЫЕ?

Этот пункт лабораторной работы останется без демонстрации, поскольку я бы просто повторил всё 4 задание ещё один раз. Как оказалось, с точки зрения использования, настроенный RAID-массив ничуть не отличается от любого другого блочного устройства. На нём можно создать файловую систему и туда что-то писать. 

А ещё лучше - создать там LVM-раздел. И делать с ним что угодно. Буквально:

![[Pasted image 20231029041400.png]]

Полезно читать компьютерные книжки. Надо как-нибудь это попробовать. 




Огромная получилась лабораторная работа. На часах 4:16 утра моего воскресенья. Буду честен, это жестоко.