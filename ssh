![[Lab06_linux.pdf]]

---

# Шаг 0. Первоначальная настройка
 
## 1. Настройка виртуальных сетевых адаптеров

В этой лабораторной работе у нас уже требования к виртуальной системе поменьше:

1. Мы хотим соединяться с хост-машиной
2. Мы хотим рабочий интернет

Для возможности соединения с хост-машиной, создадим виртуальный сетевой адаптер типа "Host-Only" и привяжем его к предварительно созданной виртуальной сети.

А для нормальной работы интернета нужно создать сетевой адаптер типа "NAT"

>[!blank | gallery alt]
>![[Pasted image 20240112184231.png]]
>
>Таблица типов виртуальных сетевых адаптеров

Продемонстрируем практически, как это должно выглядеть:  
  
>[!blank | gallery alt]
>![[Pasted image 20240112184409.png | center | 700]]
>
>Виртуальная сеть
>
>
>![[Pasted image 20240112200013.png]]
>![[Pasted image 20240112200048.png]]
>
>Виртуальные сетевые адаптеры

> [!w] Примечание 
> ![[Pasted image 20240114202008.png | float-left | 400]]
> При создании виртуальной сети Host-Only желательно включить галочку "Enable DHCP Server".
> Это нужно для того, чтобы виртуальным машинам назначались IP-адреса, по которым далее можно будет подключиться. Странно, что этот момент я не осветил в отчётах по предыдущим лабораторным. 

# 1.2. Отключим брандмауэр

Вообще, его отключать не нужно, но я это делаю для того, чтобы можно было сконцентрироваться на основном задании лабораторной.

Так, несмотря на то, что `iptables` не имеет никакой своей стандартной конфигурации в моём дистрибутиве, `firewalld` таковую имеет. Поэтому при смене порта SSH в одном из следующих заданий у меня резко пропало подключение. Дело было в том, что `firewalld` по умолчанию запрещает подключение по всем портам, кроме указанных.

По-хорошему, следовало просто настроить `firewalld`. Но не сегодня.

В своё оправдание скажу, что я это уже делал в лабораторной работе 9 курса БИС.

```bash
sudo systemctl disable firewalld
sudo systemctl stop firewalld
```

## 2. Установка и запуск OpenSSH

В большинстве дистрибутивов OpenSSH уже установлен по умолчанию. Поэтому установка не требуется. Как бы то ни было, в дистрибутиве Arch Linux при наличии такой необходимости OpenSSH можно установить следующей командой:

```bash
sudo pacman -S openssh
```

В данный пакет входит одновременно как клиент, так и сервер.

Запустим ssh-сервер:

```bash
sudo systemctl enable sshd
sudo systemctl start sshd
```

![[Pasted image 20240114200706.png | center | 800]]
## 3. Попробуем подключиться

Узнаем IP-адрес виртуальной машины:

![[Pasted image 20240114202352.png | center | 800]]

Как видим, виртуальной машине был присвоен IP-адрес `192.168.56.3`

Попробуем подключиться с хост-машины:

>[!blank | alt] 
>![[Pasted image 20240114202712.png | center | 700]]
>
>Подключение успешно
>
>![[Pasted image 20240114202816.png | center | 500]]
>
>Шалость удалась

Отлично! Значит всё работает из коробки.
И не отлично. Всё работает из коробки не самым безопасным образом. Парольная аутентификация разрешена, авторизация на root - тоже. Ну и ладно. Эти недочёты мы покроем следующими заданиями.

Также мы увидели, как ssh-клиент ругается на подключение к незнакомому хосту. 
Меня это поначалу насторожило, однако [ответ на stackoverflow](https://superuser.com/questions/1507193/what-does-this-ssh-message-mean-the-authenticity-of-host-cant-be-establis) сообщает, что это стандартное поведение клиента ssh и, более того, может нас однажды (в случае MiTM-атаки) круто выручить:

![[Pasted image 20240114203716.png | center | 700]]

# Шаг 1. Выполняем поставленные задания

## 0. Создадим секреты для аутентификации по ключу

Создание пары публичный-приватный ключ производится следующей командой:

```bash
ssh-keygen -t rsa -b 4096
```

![[Pasted image 20240114204219.png | center | 800]]

Я пароль для ключа не задавал, однако его можно настроить - и в таком случае даже при компрометации приватного ключа злоумышленнику потребуется откуда-то достать ещё и пароль.

> **Не очень важное примечание.** 
> 
> Если при создании ключа очень хочется выбрать нестандартное имя файла, скорее всего, нужно вводить полный путь для записи файла. Желательно в директории `~/.ssh`, куда они по умолчанию и сохраняются. 
> 
> Я этого не сделал и поэтому не нашёл в `~/.ssh` свои ключи. Думал, что всё поломалось. Как оказалось, если не указать конкретный путь, где нам нужно сохранить ключ, утилита сохраняет его в текущей рабочей директории. В моём случае, поскольку я консоль только открыл - это была домашняя директория.
> 
> Пришлось переместить.

Далее скопируем открытый ключ на сервер. Это делается следующей командой:

```bash
ssh-copy-id user@ip.add.re.ss
```

>[!blank | alt]
>![[Pasted image 20240114205309.png | center | 800]]
>
>Добавляем открытый ключ на сервер
>
>![[Pasted image 20240114205653.png | center | 700]]
>
>И видим - он действительно добавился!

Естественно, для добавления ключа на сервер, нам пришлось ввести пароль. Если бы у нас на данный момент уже была отключена парольная аутентификация, нужен был бы приватный ключ. 

Если бы у нас не было ни того, ни другого, возможно, нам бы пришлось генерировать пару ключей на сервере, имея к нему непосредственный физический доступ, а потом, то ли на флешке, то ли на листе бумаги, переносить приватный ключ на свою рабочую машину.

Давайте проверим, как это работает (на самом деле ))) ):

![[Pasted image 20240114210342.png | center | 800]]

Также мы могли бы войти через SSH следующим образом:
```bash
ssh user:password@ip.add.re.ss
```
В таком случае мы могли бы авторизоваться без интерактивного диалога.

## 1. Настроим SSH-сервер

Требования безопасности к настройке SSH-сервера у нас будут следующиие:
1. Запретим удалённый доступ к аккаунту root
2. Запретим подключение с пустым паролем<br>(Или запретим парольную аутентификацию вовсе)
3. Установим нестандартный порт для SSH
4. Запретим короткие ключи RSA (разрешим, допустим, только от 1024 бит)
5. Ограничим список компьютеров, с которых разрешён доступ к серверу<br>(В лабораторной работе сказано, можно сделать дважды: в настройках sshd и при помощи iptables. Поскольку можно не значит, что кровь из ушей нужно - настроим это дело только в конфиге ssh. Iptables в другой лабораторной, да и я пока, извините, наелся)
6. Будем регулярно просматривать сообщения об ошибках аутентификации в `access.log` (обязательно будем!)

### **1.0. Разберёмся, как нам с этим всем работать.**

Конфигурационные файлы SSH хранятся в `/etc/ssh`:
1. `moduli` - этот файл нас не интересует.<br>Содержит простые числа и прочие коэффиценты/данные, которые использует sshd в методе обмена ключами метода Диффи-Хеллмана. Если он скомпрометирован - это, конечно, такое.
2. `ssh_config` - конфигурация ssh **клиента**.
3. `ssh_config.d` - директория, содержит другие конфиги ssh в отдельных файлах. Все файлы оттуда читаются в лексикографическом порядке и конкатенируются в `ssh_config`. Всё потому, что `ssh_config` начинается со следующих строк:
	``` python
	# Include drop-in configurations  
	Include /etc/ssh/ssh_config.d/*.conf
	```
1. `sshd_config` - конфигурация ssh **сервера**.
2. `sshd_config.d` - аналогично `ssh_config.d`

Согласно документации, если определённому ключу в конфигурационном файле дважды присвается значение, то в конечном итоге применяется именно то, которое было первым:
> sshd(8)  reads  configuration  data  from  /etc/ssh/sshd_config (or the file specified with -f on the command  
      line).  The file contains keyword-argument pairs, one per line.  Unless noted otherwise,  for  each  keyword,  
      the  first obtained value will be used.

Во многих дистрибутивах linux в `sshd_config.d` уже записана некая начальная конфигурация. Например, у меня на Arch Linux в файле `/etc/ssh/sshd_config.d/99-archlinux.conf` записано следующее:

```bash 
# sshd_config defaults on Arch Linux  
KbdInteractiveAuthentication no  
UsePAM yes  
PrintMotd no
```

Однако, несмотря на принцип работы first match wins, все конфигурации после директивы Match обязательно перезаписывают предыдущие. Пример из конца файла `sshd_config`:

```bash
# Example of overriding settings on a per-user basis  
#Match User anoncvs  
#       X11Forwarding no  
#       AllowTcpForwarding no  
#       PermitTTY no  
#       ForceCommand cvs server
```

Из последних абзацев видно, что настройки SSH могут перекрывать друг-друга. Если появляются какие-то сомнения, что в итоге туда наприменялось, узнать, какие настройки ssh-сервера активны в данный момент можно при помощи следующей команды:

```bash
sudo sshd -T
```

![[Pasted image 20240114233114.png | center | 800]]

Очевидно, стандартный конфиг дистрибутива задан с префиксом `99` для того, чтобы иметь меньший приоритет над любыми пользовательскими конфигурациями. Это хорошо. Однако если шаловливые ручки решат модифицировать `sshd_config` напрямую, его настройки могут оказаться менее приоритетными - а это уже плохо. Поэтому думаем что и куда пишем.

Хотя писать буквы в `sshd_config` мы не собираемся, обратим внимание на то, что в нём содержится много ценной для нас информации. Куча комментариев, всяких объяснений. Да там вообще почти все строки закомментированы. Единственная незакомментированная строка, которую я там видел - разрешала sftp.

Принимаем решение конфиги из всех последующих заданий записывать в `/etc/ssh/sshd_config.d/0-my-best-config.conf`. На данный момент это пустой файл - скоро там будет жизнь.

![[Pasted image 20240114234652.png | center | 800]]

### **1.1. Запретим удалённый доступ к аккаунту root**

Для этого установим `PermitRootLogin no`.

Значением по умолчанию, в моём случае, было `PermitRootLogin without-password` - что разрешало аутентификацию в root, но только по ключу.

А ещё важно отметить, что можно установить значение `PermitRootLogin=forced-commands-only` - это очень полезная штука, позволяет аутентификацию в root, но удалённый пользователь сможет вводить исключительно разрешённые команды. Например, запускать резервное копирование данных - обычно это операция, требующая root-доступа. 

Список разрешённых команд задаётся для каждого ключа индивидуально, следующим образом:

```bash
command="/path/to/rrsync -wo /allowed/directory/",restrict,from="a.b.c.d" ecdsa-sha2-nistp521 AAAAE...
```

### **1.2. Запретим парольную аутентификацию**

Если бы мы хотели отключить аутентификацию для пользователей без пароля, нужно было бы установить `PermitEmptyPasswords=no`. Однако перед нами стоит немного другая задача.

Чтобы запретить парольную аутентификацию, установим:

```bash
PasswordAuthentication no
```

Однако так мы, на самом деле, запрещаем лишь простую парольную аутентификацию, при которой пароль запрашивается SSH-клиентом и далее передаётся на сервер. 

Также нам нужно запретить интерактивную парольную аутентификацию, при которой пароль запрашивается уже на стороне сервера в диалоге:

```bash
KbdInteractiveAuthentication no
```

Также интернете можно найти рекомендацию отключить `ChallengeResponseAuthentication` - однако это просто устаревший alias для `KbdInteractiveAuthentication`

Много где в интернете можно найти рекомендацию записать `UsePAM=no`, однако в этом нет необходимости, поскольку мы УЖЕ отключили интерактивную аутентификацию - при этом нам всё ещё никак не вредит использование PAM-модуля:

```
# Set this to 'yes' to enable PAM authentication, account processing,
# and session processing. If this is enabled, PAM authentication will
# be allowed through the ChallengeResponseAuthentication and
# PasswordAuthentication.  Depending on your PAM configuration,
# PAM authentication via ChallengeResponseAuthentication may bypass
# the setting of "PermitRootLogin without-password".
# If you just want the PAM account and session checks to run without
# PAM authentication, then enable this but set PasswordAuthentication
# and ChallengeResponseAuthentication to 'no'.
UsePAM yes
```

На форумах в интернетах тоже пишут хорошие вещи:

![[Pasted image 20240115002158.png | center | 800]]

### **1.3. Установим нестандартный порт SSH**

Тут ничо интересного сказать не могу:

```bash
Port 22869
```

### **1.4. Запретим короткие ключи RSA**

В условии задания было предложено установить минимальный размер в 1024 бита. В этом большого смысла нет, поскольку, согласно документации, 1024 - и так стандартное значение.

```
RequiredRSASize 2048
```

### **1.5. Ограничим список разрешённых к подключению компьютеров**

Сначала запретим аутентификацию через ключ:

```bash
PubkeyAuthentication no
```

Потом разрешим её, но уже только для IP-адресов в локальной сети:

```bash
Match Address 192.168.*.*
    PubkeyAuthentication yes
```

Стоит отметить, что в этом случае другие компьютеры всё же смогут подключиться к нашему ssh-серверу - однако не смогут войти, поскольку для них не найдётся методов аутентификации.

Если мы захотим реально по-жёсткому запретить саму возможность подключения, нужно будет сконфигурировать фейерволл. Например, для `iptables` это выглядело бы следующим образом:

```bash
iptables -A INPUT -p tcp --dport 22 --source 192.168.0.0/24 -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -j DROP
```

### **1.6. Регулярно просматривать `access.log`**

Здесь нам ничего делать не нужно - только взять на заметку. Хорошо.

Однако я нашёл способ, как можно уведомлять себя на электронную почту при попытках входа SSH. Мне показался [этот ответ](https://askubuntu.com/questions/179889/how-do-i-set-up-an-email-alert-when-a-ssh-login-is-successful) на StackOverflow интересным, поэтому приведу его ниже:

![[Pasted image 20240115004841.png | center | 700]]

Это неплохой пример, в каких случаях нам может быть полезен `UsePAM yes` даже при отключенной парольной аутентификации. И вообще, решение гибкое и интересное, мне оно нравится.

### **1.7. Перестанем говорить - и наконец напишем конфиг**

В итоге у нас получается следующая конфигурация:

```bash
# /etc/ssh/sshd_config.d/0-my-best-config.conf

Port 22869

PermitRootLogin no

PasswordAuthentication no
KbdInteractiveAuthentication no
PubkeyAuthentication no

RequiredRSASize 2048

Match Address 192.168.*.*
    PubkeyAuthentication yes
```

Перезагрузим SSH-сервер:

```bash
sudo systemctl restart sshd
```

И проверим, как применилась конфигурация:

![[Pasted image 20240115005812.png | center | 600]]

Попробуем подключиться:
>[!blank | alt]
>![[Pasted image 20240115011152.png | center | 800]]
>
>Подключение работает
>
>![[Pasted image 20240115011232.png | center | 700]]
>
>Команды вводятся

## 2. Настроим проброс X11-сессии

Для этого на удалённой системе должен быть установлен `xauth`. В моём случае он уже был установлен.

```bash
sudo pacman -S xorg-xauth
```

Далее разрешим проброс X11-сессии в конфигурационном файле SSH:

```bash
# /etc/ssh/sshd_config.d/01-x11-forwarding.conf
X11Forwarding yes
```

Перезагрузим SSH-сервер:

```bash
sudo systemctl restart sshd
```

И проверим, как оно работает:

![[Pasted image 20240115012134.png | center | 800]]

А никак оно не работает. 

Настроим .Xauthority, честно повторив действия [из ответа на stackoverflow](https://superuser.com/questions/806637/xauth-not-creating-xauthority-file) и совершенно не понимая смысл своих действий:

```bash
# Rename the existing .Xauthority file by running the following command
mv .Xauthority old.Xauthority 

# xauth with complain unless ~/.Xauthority exists
touch ~/.Xauthority

# only this one key is needed for X11 over SSH 
xauth generate :0 . trusted 

# generate our own key, xauth requires 128 bit hex encoding
xauth add ${HOST}:0 . $(xxd -l 16 -p /dev/urandom)

# To view a listing of the .Xauthority file, enter the following 
xauth list
```

Снова проверим работоспособность:

>[!blank | alt]
>![[Pasted image 20240115013954.png]]
>
>Вроде никакими ошибками не сыплет
>
>![[Pasted image 20240115014513.png]]
>
>И браузер запускается! Только чувствует себя совсем бедовенько - больно уж тяжело такие приложения пробрасывать.
>И звук. Его никто не обещал. :(
>
>![[Pasted image 20240115014124.png]]
>
>В игрушки тоже не поиграть :(
>
>![[Pasted image 20240115014755.png]]
>
>Главное, что грузятся все важные рабочие инструменты!
>
>![[Pasted image 20240115015123.png]]
>
>А если серьёзно - всё, что нужно для работы - точно запустится и худо-бедно отрисуется.

## 3. Подключение по VNC

Для начала, установим следующий пакет как на хост-машину, так и на виртуальную:

```bash
# В пакете содержится сразу и клиент, и сервер.
# В других дистрибутивах это может отличаться и клиент-сервер могут быть разбиты на несколько пакетов.
sudo pacman -S tigervnc
```

После чего начнём настраивать VNC на стороне сервера.

Установим VNC-пароль:

```bash
vncpasswd
```

![[Pasted image 20240115021715.png | center | 800]]

Установим соответствие портов для подключения и пользователей:

![[Pasted image 20240115021847.png | center | 800]]

Здесь `:число` - номер VNC-дисплея.
А подключаемся мы по порту, который равен `5900+номер_дисплея`

Иначе говоря, для подключения к пользователю `user` мы будем использовать порт `5901`

Запишем настройки подключения для нашего пользователя:

![[Pasted image 20240115022613.png | center | 800]]

Здесь мы указали сессию plasma. Это потому что у меня среда рабочего стола KDE. А посмотреть список доступных сред рабочего стола можно так: `ls /usr/share/xsessions`

Также мы указали в 3 строке, что подключение к нам возможно только из `localhost`. Это для безопасности. Поскольку мы и так будем пробрасывать шифрованный SSH-тонель, нам нет никакого смысла держать доступный для внешнего мира VNC-сервер.

И также запустим VNC-сервер:
<span style="font-size: 1.5rem">(!!!) Забегая наперёд, НЕТ. То, что я только что сделал, делать НЕ НУЖНО. Предлагаю прочитать дальше, прежде чем что-то вводить в терминал)</span>

![[Pasted image 20240115023344.png | center | 800]]

Обратим внимание, что нужно ОБЯЗАТЕЛЬНО написать `:` перед номером дисплея.
Обратим внимание, что каждый дисплей VNC рассматривается как отдельный сервис - что очень гибко.

Создадим SSH-тонель:

![[Pasted image 20240115024847.png | center | 800]]

И попробуем подключиться:

>[!blank | alt]
>![[Pasted image 20240115025103.png | center | 800]]
>
>Пока что всё хорошо...
>
>![[Pasted image 20240115025140.png | center | 800]]
>
>А теперь всё плохо!

Видим чёрный экран.

Читаем вики:

![[Pasted image 20240115025340.png | center | 800]]

Ага, теперь понятно, что проблема была из-за того, что на момент подключения у меня уже была сессия в виртуальной машине. По сути, у меня всё пробрасывалось, просто мне пробрасывалось ничто.

Также я долго думал, почему при каждом выходе пользователя из сеанса сервис `vncserver@:1` выключается. Оказывается, ТАК И ДОЛЖНО БЫТЬ.

Как только этот сервис включен - у нас включен VNC-сервер. И сессия, чисто по идее, уже должна куда-то пробрасываться.

Из-за того, что я включил VNC с уже запущенной сессией, я начал получать странные артифакты работы сервиса. Например, на основном сеансе у меня всё работало - но интерфейс выхода из системы вместо того, чтобы отобразиться на виртуальной машине, появился на этом самом чёрном экране.

И даже более того, из-за того, что я включил автозапуск этого сервиса, после перезагрузки виртуальной машины я просто не смог в неё войти. Потому что графическая сессия уже пробрасывается, создать её ещё раз нельзя. Получаем зависание на экране загрузки и чёрный экран.

**Меняем тактику:** 
1. Всё, что было после (!!!) - считать не действительным. Никакого автозапуска не нужно.
2. Просто выходим из основной графической сессии целевого пользователя.
3. Создаём SSH-тонель
4. И там уже, в SSH-сессии с тунеллированным подключением, там включаем VNC-сервер
5. Подключаемся
6. Как сделаем свои дела и захотим подключиться к сессии из виртуальной машины - отключаем vnc-сервер: `sudo systemctl stop vncserver@:1`

Попробуем:
>[!blank | alt]
>![[Pasted image 20240115033414.png | center | 800]]
>
>Вот тут всё хорошо
>
>>[!blank | gallery]
>>![[Pasted image 20240115033506.png]]
>>![[Pasted image 20240115033526.png]]
>
> Подключаемся
> 
> ![[Pasted image 20240115033723.png]]
> 
> И всё работает как надо

## 4. Настроим подключение к УЖЕ СУЩЕСТВУЮЩЕЙ сессии через VNC

Хорошо. На самом деле, только что была какая-то лажа.
Если мы хотим подключиться к компьютеру и что-то там графически поделать, если это сервер и там требуется какая-то конфигурация, туда-сюда - это всё нормально.

Но если мы хотим покосплеить TeamViewer?
Ведь это самый частый сценарий использования.

Тут всё проще. И подводных камней я не нашёл.

Нужно просто запустить `x0vncserver`:

![[Pasted image 20240115034524.png | center | 800]]

Он, в свою очередь, радостно рапортует о том, что доступен для подключения по порту 5900.
Хорошо, значит пробрасывать будем порт 5900.

Создаём SSH-сессию-тунель:

![[Pasted image 20240115034715.png | center | 800]]

Подключаемся:

![[Pasted image 20240115034846.png | center | 600]]

![[Pasted image 20240115034826.png]]

Всё отлично работает. 

А если бы мы очень захотели автоматический запуск, это можно было бы сделать всего одним простым юнитом systemd:

![[Pasted image 20240115035252.png | center | 800]]
