![[Lab05_linux.pdf]]

---

# Шаг 0 - Предварительная настройка всяких штук

## 1. Настройка сетевого адаптера ВМ

Данный шаг аналогичен [[Lab 9 - Применение SSL для защиты трафика web-приложений#3. Настройка виртуальной сети между виртуальной- и хост-машинами|сделанному]] в начале 9 лабораторной курса БИС, однако с отличиями. Наши требования такие:
1. У нас главная ВМ, **первая тестовая** ВМ и **вторая тестовая** ВМ
2. Есть 2 виртуальные сети
	2. По первой основная ВМ доступна для первой тестовой ВМ.
	3. По второй основная ВМ доступна для второй тестовой ВМ
	4. Первоя и вторая тестовые ВМ не имеют прямого доступа друг к другу
3. Таким образом основная ВМ как бы подключена "к двум сетям"
4. Хотим инторнет

Для создания виртуальных введём следующие команды:

```bash
vboxmanage dhcpserver add --netname intnet1 --ip 10.10.10.1 --netmask 255.255.255.0 --lowerip 10.10.10.2 --upperip 10.10.10.212 --enable

vboxmanage dhcpserver add --netname intnet2 --ip 10.10.11.1 --netmask 255.255.255.0 --lowerip 10.10.11.2 --upperip 10.10.11.212 --enable
```

И подключаем виртуальные машины к этим сетям посредством сетевых адаптеров типа "Internal network" (+ последний сетевой адаптер типа NAT, чтобы был инторнет):

Основная ВМ:

![[Screenshot_20240105_203550.png]]![[Screenshot_20240105_203603.png]]![[Screenshot_20240105_203725.png]]

Первая тестовая ВМ:

![[Screenshot_20240105_203835.png]]![[Screenshot_20240105_203846.png]]

Вторая тестовая ВМ:

![[Screenshot_20240105_203913.png]]![[Screenshot_20240105_203929.png]]

## 2. Посмотрим выдачу `ifconfig`

Нам нужно знать, куда стучаться и проверить, всё ли настроилось правильно. Посмотрим, что пишет `ifconfig` на основной ВМ:

![[task1_4_ifconfig_mainvm.png | center | 700]]

Видим следующие сетевые интерфейсы:

1. `enp0s3` (10.10.10.4) - сюда мы будем подключаться из первой тестовой ВМ
2. `enp0s8` (10.10.11.2) - сюда мы будем подключаться из второй тестовой ВМ
3. `enp0s9` (10.0.4.15) - это виртуальный адаптер NAT, он для интернета
4. `lo` - локалхост

Нас, значит, интересуют первые два. 

## 3. Удаление встроенного в дистрибутив брандмауэра

В моём дистрибутиве (EndeavourOS - основан на Arch Linux, но с добавлением графического инсталлера и минимального набора системных утилит из коробки) по умолчанию установлен и запущен встроенный брандмауэр.

Это `firewalld`. Конфигурировать его можно при помощи утилиты `firewall-cmd`.
Его интерфейс довольно удобен, однако, как (только что!) показала моя практика, его конфигурация может конфликтовать с конфигурацией `iptables`.

Например, у меня в `iptables` на данный момент нет ещё ни одного правила, однако соединение `telnet` обрубалось и всё на том.

Для того, чтобы выполнять задания касаемые `iptables` и не делать поправок на присутствие в системе `firewalld` - просто удалим его.

![[task1_2_remove_firewall 1.png]]

А вообще, можно было и просто отключить:

```bash
sudo systemctl disable firewalld
sudo systemctl stop firewalld
```

## 4. Установка telnet на ВМ

В этой лабораторной работе нам нужно будет делать всякие умные штуки, а потом их проверять. Проверять будем в том числе на примере telnet-соединения.

Установим telnet-сервер так, как это рекомендуется [на вики](https://wiki.archlinux.org/title/Telnet):

```bash
sudo pacman -S inetutils
sudo systemctl enable telnet.socket
sudo systemctl start telnet.socket
```

Дальнейшая конфигурация не требуется.

Проверим, что telnet вообще работает:

![[task0_telnet_check.png]]

Проверим, как telnet доступен с тестовых ВМ:

![[Screenshot_20240105_204716.png]]

Всё работает ожидаемым образом:
1. Из первой тестовой ВМ
	1. мы можем подключиться к telnet через первую виртуальную сеть
	2. мы не можем подключиться к telnet через вторую виртуальную сеть
2. Из второй тестовой ВМ
	1. мы можем подключиться к telnet через вторую виртуальную сеть
	2. мы не можем подключиться к telnet через первую виртуальную сеть

# Шаг 1 - Изучим существующие правила `iptables`, потом сохраним их на диск

![[task0_list.png]]

Их нет.

Поскольку правил нет, то и сохранять нечего. Не буду ничего делать.

Если всё же захочется этим заняться, сохранение и восстановление правил `iptables` можно организовать следующим образом:

```bash
sudo iptables-save > /path/to/backup.fw
sudo iptables-restore < /path/to/backup.fw
```

# Шаг 2 - Выполняем задания

## 1. Блокировка всего трафика с второй тестовой ВМ

```bash
sudo iptables -A INPUT -s <IP_ADDRESS> -j DROP
```

IP адрес второй тестовой ВМ во второй виртуальной сети - `10.10.11.3`

![[Pasted image 20240105214237.png]]

Как видно, первая тестовая ВМ успешно получает доступ, а второй тестовой ВМ не пришёл даже ответ с отказом! (это потому что DROP, а не REJECT)

## 2. Блокировка HTTP/HTTPS трафика на целевой веб-сайт по его хосту

```bash
sudo iptables -A OUTPUT -p tcp -m multiport --dports 80,443 -d <WEBSITE_HOSTNAME> -j DROP
```

![[Pasted image 20240105215212.png]]

ВГУ не работает, ВитВодка не работает - а Википедия работает

## 3. Удалим одно из правил блокировки сайта

```bash
sudo iptables -D CHAIN RULE_NUMBER
```

![[Pasted image 20240105215728.png]]

Теперь ВитВодка снова грузится

## 4. А другое правило блокировки сайта заменим

Теперь будем блокировать `vsmu.by` вместо `vsu.by`. И блокировать будем трафик только одного конкретного сетевого интерфейса.

```bash
sudo iptables -R CHAIN RULE_NUMBER NEW_RULE
```

![[Pasted image 20240105221227.png]]

ВГУ снова грузится, а ВГМУ перестал. С Википедией всё стабильно.

## 5. Удалим все правила

```bash
sudo iptables -F CHAIN
```

![[Pasted image 20240105221504.png]]

## 6. Напишем хитрый набор хитрых правил

Будем считать, что сеть с первой тестовой ВМ доверенная, а со второй - недоверенная.

1. В недоверенной сети, касаемо настраиваемой ВМ:
	1. Есть доступ к веб-серверу
	2. Есть возможность пересылки почты
	3. Запрещён доступ к ssh и telnet. Попытки протоколировать
2. В доверенной сети, касаемо настраиваемой ВМ:
	1. Есть доступ к ssh, web, почте и ftp
	2. Есть доступ к telnet - но только от одного конкретного адреса из этой сети - то есть с первой тестовой машины.

Оформим это дело в виде bash-скрипта:

```bash
#!/bin/bash

# ------------------------------------------------------------
# Предварительные настройки

# Очищаем существующие правила iptables
iptables -F
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT DROP

# Разрешаем loopback
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# ------------------------------------------------------------
# Недоверенная сеть (enp0s8)

# Разрешаем доступ к Apache
iptables -A INPUT -i enp0s8 -p tcp --dport 80 -j ACCEPT
# Разрешаем возможность пересылки почты (предположим, используется SMTP на порту 25)
iptables -A INPUT -i enp0s8 -p tcp --dport 25 -j ACCEPT
# Запрещаем доступ к ssh и telnet, логируем попытки
iptables -A INPUT -i enp0s8 -p tcp --dport 22 -j LOG --log-prefix "SSH Access Attempt: "
iptables -A INPUT -i enp0s8 -p tcp --dport 22 -j DROP
iptables -A INPUT -i enp0s8 -p tcp --dport 23 -j LOG --log-prefix "Telnet Access Attempt: "
iptables -A INPUT -i enp0s8 -p tcp --dport 23 -j DROP

# -------------------------------------------------------------
# Доверенная сеть (enp0s3)

# Разрешаем доступ к ssh, web, почте и ftp
iptables -A INPUT -i enp0s3 -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -i enp0s3 -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -i enp0s3 -p tcp --dport 25 -j ACCEPT
iptables -A INPUT -i enp0s3 -p tcp --dport 21 -j ACCEPT
# Разрешаем доступ к telnet только от одного конкретного адреса
iptables -A INPUT -i enp0s3 -p tcp --dport 23 -s доверенный_IP_адрес -j ACCEPT
# Запрещаем все остальные входящие соединения
iptables -A INPUT -i enp0s3 -j DROP

# -------------------------------------------------------------
# Сеть для интернета (enp0s9)

# Разрешаем все исходящие соединения
iptables -A OUTPUT -o enp0s9 -j ACCEPT

# -------------------------------------------------------------
# Прочее

# Разрешаем установленные соединения и их состояния
# Без этой конфигурации мы сможем отправить запрос в интернет, но не сможем получить связанный с тем запросом ответ - или сможем принять запрос на подключение по telnet - но при этом не сможем отправить свой положительный ответ клиенту
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Разрешаем пинг
iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT
iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT

# Запрещаем все остальные исходящие и входящие соединения
iptables -A INPUT -j DROP
iptables -A OUTPUT -j DROP
```

И запустим его из-под root, чтобы применить настройки:

```bash
chmod +x /path/to/script.sh
/path/to/script.sh
```

## 6.2. Проверим, как оно работает на самом деле

### 1. Проверка доступа по telnet

1. Соединение из недоверенной сети сброшено![[Pasted image 20240106001830.png]]
2. Соединение из доверенной сети и доверенного ПК установлено![[Pasted image 20240106002528.png]]
3. Логи опосля попытки доступа из недоверенной сети записаны![[Pasted image 20240106002802.png]]

### 2. Проверка доступа по иным протоколам

Этой проверки не будет. Мне бы пришлось устанавливать и настраивать слишком много всяких серверов. =(

Ну и ладно! В общем и целом, политики касаемо этих протоколов полностью аналогичны политики для telnet, помимо того, что мы не ведём логи.

Так что есть все основания полагать, что оно будет работать.

### 3. Проверка работоспособности loopback

![[Pasted image 20240106003131.png]]

Коль соединение по локалхосту устанавливается - значит и `lo` интерфейс работает как следует.

### 4. Интернет?

![[Pasted image 20240106003235.png]]

Работает.

Почему - написано в комментариях к скрипту.


### 5. Пинг?

![[Pasted image 20240106003629.png]]

Понг

# 7. Сохранение заданных правил

![[Pasted image 20240106004009.png]]

Я перезагрузился - и всё пропало!

[Прочитаем вики](https://wiki.archlinux.org/title/iptables#Configuration_and_usage), вынесем из этого следующий вывод.

По умолчанию вместе с `iptables` также поставляется systemd-юнит `iptables.service`. По умолчанию он выключен. Его можно включить. При своём старте этот юнит читает файл `/etc/iptables/iptables.rules` (или `/etc/iptables/ip6tables.rules` для `ip6tables`) и применяет правила оттуда.

Включим юнит:

```bash
sudo systemctl enable iptables
```

Сохраним правила в конфиг:

```bash
sudo iptables-save -f /etc/iptables/iptables.rules
```

Если очень хочется, можем единоразово загрузить правила:

```bash
# Путём запуска юнита
sudo systemctl start iptables
# Или напрямую
sudo iptables-restore /etc/iptables/iptables.rules
```

Перейдём к практике:

1. Включим тот самый юнит systemd:![[Pasted image 20240106004846.png]]
2. Снова загрузим правила из файла:![[Pasted image 20240106004748.png]]
3. Чисто ради интереса! - посмотрим содержимое конфига по умолчанию, перед тем, как туда что-то писать:![[Pasted image 20240106004955.png]]
4. Запишем туда правила:![[Pasted image 20240106005059.png]]
5. Перезагрузимся - и возрадуемся!![[Pasted image 20240106005343.png]]<br>Я честно перезагружался.

# Шаг 3 - отвечаем на вопросы

*Сначала набор правил, потом - объяснение.*

```bash
iptables -A INPUT -p tcp --syn -j DROP
```

Блокирует все входящие syn запросы. Учитывая, что tcp-соединение всегда начинается с рукопожатия (syn, syn-ack, ack) - видимо, больше никто не сможет нормально установить с нами такое соединение. 

```bash
iptables -A INPUT -m mac --mac-source 00:01:34:56:AB:CD -j DROP
```

Блокирует все входящие запросы с машины с заданным MAC-адресом

```bash
iptables -A INPUT -m state --state ESTABILISHED,RELATED -j ACCEPT
```

Полезная штука, уже рассматривали её в скрипте выше. Разрешает все входящие соединения, при условии, что они относятся к какому-то уже установленному соединению. Даже если в целом входящие соединения у нас заблокированы.

Пример: мы отправили запрос, чтобы получить содержимое страницы какого-нибудь сайта. Этот запрос пройдёт через цепочку `OUTPUT`. Сервер скажет, что всё окей. Отправит нам какой-то ответ. Ответ попытается пройти через цепочку `INPUT`. Но мы блокируем входящие запросы! И мы не сможем получить свой ответ и будем думать, что ответ не приходит.

Но после применения этого правила мы всё-таки получим свой ответ, поскольку этот пакет относится к уже установленному соединению. И мы получим содержимое странички.

```bash
iptables -A OUTPUT -o eth0 -p tcp --dport 443 -m state --state NEW,ESTABILISHED -j ACCEPT
iptables -A INPUT -i eth0 -pp tcp --sport 443 -m state --state ESTABILISHED -j ACCEPT
```

Эти правила позволяют устанавливать исходящие TCP-соединения на порт 443 и принимать входящий трафик, связанный с этими соединениями. Думаю, в первом правиле мы можем убрать `--state NEW,ESTABILISHED` и получить тот же результат...

```bash
iptables -A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT
iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT
```

Первым правилом разрешаем отправлять ICMP-запросы на другие сервера. Вторым правилом разрешает отправлять другим серверам ICMP-ответы. 

```bash
iptables -A OUTPUT -p udp -o eth0 --dport 53 -j ACCEPT
iptables -A INPUT -p udp -i eth0 --sport 53 -j ACCEPT
```

Разрешаем входящие и исходящие DNS-соединения, но только через интерфейс eth0

```bash
# Создает новую цепочку с именем LOGGING
iptables -N LOGGING
# Перенаправляет все пакеты, которые дошли до этой точки в цепочке INPUT, в цепочку LOGGING
iptables -A INPUT -j LOGGING
# Устанавливает правило в цепочке LOGGING, которое лимитирует логирование до 10 сообщений в минуту. Если количество пакетов превышает это ограничение, дальнейшие пакеты будут проходить без логирования. Логирование выполняется с префиксом "IPTables Packet Dropped:" и уровнем логирования 7.
iptables -A LOGGING -m limit --limit 10/min -j LOG --log-prefix "IPTables Packet Dropped: " --log-level 7
# Отбрасывает все пакеты, которые дошли до цепочки LOGGING после логирования.
iptables -A LOGGING -j DROP
```

Эти правила настроены на создание цепочки (chain) LOGGING для логирования пакетов, которые были отброшены предыдущими правилами в цепочке INPUT.  Подробнее в комментариях. 

```bash
В чём разница между целями DROP и REJECT?
```

DROP - игнорирует существование пакета. Как будто его вовсе не было. Отправитель, в свою очередь, его произвольно долго оeжидает и, возможно, когда-нибудь дожидается таймаута.

REJECT - тоже имеет запретительный эффект. Но не занимается психологическим абьюзом. "Соединение кэннот би эстабилишед"

С одной стороны, REJECT человечнее. С другой стороны, REJECT палит, что на порту всё-таки есть какой-то сервер! Ответ о невозможности установления соединения - это тоже ответ. Раскрытие небольшой, но, возможно, важной для безопасности информации. А вдруг отправитель злодей и сканирует сеть? А потом будет что-то очень плохое делать. В таком случае, может быть лучше воспользоваться DROP. И никто ничего не поймёт.